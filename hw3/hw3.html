<!DOCTYPE html>
<html>
<head>
<style>
	#info {
		position: absolute;
		top: 10px; width: 100%;
		
		padding: 5px;
		text-align: center;
		font-size: 20px;
		color: #ffff00
	} 
	body {
		overflow: hidden
  }
</style>


</head>

<body id = body>

<div id='info'> Minecraft Steve <br> 
<button id='switchgod'>God Perspective</button>
<button id='switch1'>First Perspective</button>
<button id='switch3'>Third Perspective</button><br>
<button id='switchgyro'>Gyro Camera</button>
</div>
<script src="https://threejs.org/build/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
<script src="https://threejs.org/examples/js/misc/Gyroscope.js"></script>
<script>
var renderer, scene, camera, clock;
var cameraGyro;
var keyboard = new KeyboardState();
var speed, angle, vel;
var pos = new THREE.Vector3();
var cameraHelper
var camera3rd, use3rd = 4;
var T = 1;
var clock = new THREE.Clock();
var ts = clock.getElapsedTime();

var pose1 = {
	lThigh: Math.PI/6,
    rThigh: -Math.PI/6
}
var pose2 = {
	lThigh: -Math.PI/6,
    rThigh: Math.PI/6
}
var keys = [
  [0, pose1],
  [0.5, pose2],
  [1, pose1]
];


$('#switchgod').click ( function () {
	use3rd = 2;
})
$('#switch1').click ( function () {
	use3rd = 1;
})
$('#switch3').click ( function () {
	use3rd = 3;
})
$('#switchgyro').click ( function () {
	use3rd = 4;
});

(function() {
  Math.clamp = function(val,min,max){
    return Math.min(Math.max(val,min),max);
    
  }})();
  
init();
animate();

function calcPose(ext) {
  pose1 = {
    lThigh: Math.min(speed*T*ext*0.03, Math.PI/2.4),
    rThigh: Math.max(-speed*T*ext*0.03, -Math.PI/2.4)
  }
  pose2 = {
    lThigh: Math.max(-speed*T*ext*0.03, -Math.PI/2.4),
    rThigh: Math.min(speed*T*ext*0.03, Math.PI/2.4)
  }
 keys = [
  [0, pose1],
  [0.5, pose2],
  [1, pose1]
];
}

function keyframe(t) {
  var s = ((t - ts) % T) / T;

  for (var i = 1; i < keys.length; i++) {
    if (keys[i][0] > s) break;
  }
  // take i-1
  var ii = i - 1;
  var a = (s - keys[ii][0]) / (keys[ii + 1][0] - keys[ii][0]);
  intKey = [keys[ii][1].lThigh * (1 - a) + keys[ii + 1][1].lThigh * a,
            keys[ii][1].rThigh * (1 - a) + keys[ii + 1][1].rThigh * a
  ];
	return intKey;
}
//120~917都在貼材質
function buildHead(WW, HH, DD, texture) {

  var geometry = new THREE.BufferGeometry();	
  var vertices = [];
  var indices = [];
  var uvs = [];
  const ww = 1;
  const hh = 3;
  const UU = 16*ww;
  const VV = 3*hh + 7*ww;
  
  var a = {u: 2*ww, v: hh+5*ww+(2*ww+2*hh)};
  var b = {u: 4*ww, v: hh+5*ww+(2*ww+2*hh)};
  var c = {u: 6*ww, v: hh+5*ww+(2*ww+2*hh)};
  var d = {u: 0, v: hh+3*ww+(2*ww+2*hh)};
  var e = {u: 2*ww, v: hh+3*ww+(2*ww+2*hh)};
  var f = {u: 4*ww, v: hh+3*ww+(2*ww+2*hh)};
  var g = {u: 6*ww, v: hh+3*ww+(2*ww+2*hh)};
  var h = {u: 8*ww, v: hh+3*ww+(2*ww+2*hh)};
  var i = {u: 0, v: hh+ww+(2*ww+2*hh)};
  var j = {u: 2*ww, v: hh+ww+(2*ww+2*hh)};
  var k = {u: 4*ww, v: hh+ww+(2*ww+2*hh)};
  var l = {u: 6*ww, v: hh+ww+(2*ww+2*hh)};
  var m = {u: 8*ww, v: hh+ww+(2*ww+2*hh)};

  // PZ
  vertices.push(-WW/2,HH/2,DD/2, -WW/2,-HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,HH/2,DD/2 ); // 0,3,2,1
  indices.push(0,1,2, 0,2,3);
	uvs.push (e.u/UU,e.v/VV, j.u/UU,j.v/VV, k.u/UU,k.v/VV, f.u/UU,f.v/VV); // e,j,k,f

	// PX
  vertices.push(WW/2,HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,-HH/2,-DD/2, WW/2,HH/2,-DD/2 ); // 1,2,6,5
  indices.push (4,5,6, 4,6,7); // [0,1,2, 0,2,3] + 4
	uvs.push (f.u/UU,f.v/VV, k.u/UU,k.v/VV, l.u/UU,l.v/VV, g.u/UU,g.v/VV); // f,k,l,g
	
	// NX
  vertices.push(-WW/2,HH/2,-DD/2, -WW/2,-HH/2,-DD/2, -WW/2,-HH/2,DD/2, -WW/2,HH/2,DD/2 ); // 4,7,3,0
  indices.push (8,9,10, 8,10,11); // [0,1,2, 0,2,3] + 8
	uvs.push (d.u/UU,d.v/VV, i.u/UU,i.v/VV, j.u/UU,j.v/VV, e.u/UU,e.v/VV); // d,i,j,e

	// NZ
  vertices.push(WW/2,HH/2,-DD/2, WW/2,-HH/2,-DD/2, -WW/2,-HH/2,-DD/2, -WW/2,HH/2,-DD/2 ); // 5,6,7,4
  indices.push (12,13,14, 12,14,15); // [0,1,2, 0,2,3] + 12
	uvs.push (g.u/UU,g.v/VV, l.u/UU,l.v/VV, m.u/UU,m.v/VV, h.u/UU,h.v/VV); // g,l,m,h
	//PY
  vertices.push(-WW/2,HH/2,-DD/2, -WW/2,HH/2,DD/2, WW/2,HH/2,DD/2, WW/2,HH/2,-DD/2 );  // 4 0 1 5
  indices.push (16,17,18, 16,18,19); // [0,1,2, 0,2,3] + 16
	uvs.push (a.u/UU,a.v/VV, e.u/UU,e.v/VV, f.u/UU,f.v/VV, b.u/UU,b.v/VV); // a,e,f,b
	//NY
  vertices.push(-WW/2,-HH/2,-DD/2, -WW/2,-HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,-HH/2,-DD/2 );  // 7 3 2 6
  indices.push (20,21,22, 20,22,23); // [0,1,2, 0,2,3] + 20
	uvs.push (b.u/UU,b.v/VV, f.u/UU,f.v/VV, g.u/UU,g.v/VV, c.u/UU,c.v/VV); // b,f,g,c

	geometry.setIndex(indices);  
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));	
	
  let head = new THREE.Mesh (geometry, new THREE.MeshBasicMaterial({map: texture, transparent: true, side:THREE.DoubleSide}));
	return head;
}

function buildHeadArmor(WW, HH, DD, texture) {

  var geometry = new THREE.BufferGeometry();	
  var vertices = [];
  var indices = [];
  var uvs = [];
  const ww = 1;
  const hh = 3;
  const UU = 16*ww;
  const VV = 3*hh + 7*ww;
  
  var a = {u: 2*ww+8*ww, v: hh+5*ww+(2*ww+2*hh)};
  var b = {u: 4*ww+8*ww, v: hh+5*ww+(2*ww+2*hh)};
  var c = {u: 6*ww+8*ww, v: hh+5*ww+(2*ww+2*hh)};
  var d = {u: 0+8*ww, v: hh+3*ww+(2*ww+2*hh)};
  var e = {u: 2*ww+8*ww, v: hh+3*ww+(2*ww+2*hh)};
  var f = {u: 4*ww+8*ww, v: hh+3*ww+(2*ww+2*hh)};
  var g = {u: 6*ww+8*ww, v: hh+3*ww+(2*ww+2*hh)};
  var h = {u: 8*ww+8*ww, v: hh+3*ww+(2*ww+2*hh)};
  var i = {u: 0+8*ww, v: hh+ww+(2*ww+2*hh)};
  var j = {u: 2*ww+8*ww, v: hh+ww+(2*ww+2*hh)};
  var k = {u: 4*ww+8*ww, v: hh+ww+(2*ww+2*hh)};
  var l = {u: 6*ww+8*ww, v: hh+ww+(2*ww+2*hh)};
  var m = {u: 8*ww+8*ww, v: hh+ww+(2*ww+2*hh)};

  // PZ
  vertices.push(-WW/2,HH/2,DD/2, -WW/2,-HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,HH/2,DD/2 ); // 0,3,2,1
  indices.push(0,1,2, 0,2,3);
	uvs.push (e.u/UU,e.v/VV, j.u/UU,j.v/VV, k.u/UU,k.v/VV, f.u/UU,f.v/VV); // e,j,k,f

	// PX
  vertices.push(WW/2,HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,-HH/2,-DD/2, WW/2,HH/2,-DD/2 ); // 1,2,6,5
  indices.push (4,5,6, 4,6,7); // [0,1,2, 0,2,3] + 4
	uvs.push (f.u/UU,f.v/VV, k.u/UU,k.v/VV, l.u/UU,l.v/VV, g.u/UU,g.v/VV); // f,k,l,g
	
	// NX
  vertices.push(-WW/2,HH/2,-DD/2, -WW/2,-HH/2,-DD/2, -WW/2,-HH/2,DD/2, -WW/2,HH/2,DD/2 ); // 4,7,3,0
  indices.push (8,9,10, 8,10,11); // [0,1,2, 0,2,3] + 8
	uvs.push (d.u/UU,d.v/VV, i.u/UU,i.v/VV, j.u/UU,j.v/VV, e.u/UU,e.v/VV); // d,i,j,e

	// NZ
  vertices.push(WW/2,HH/2,-DD/2, WW/2,-HH/2,-DD/2, -WW/2,-HH/2,-DD/2, -WW/2,HH/2,-DD/2 ); // 5,6,7,4
  indices.push (12,13,14, 12,14,15); // [0,1,2, 0,2,3] + 12
	uvs.push (g.u/UU,g.v/VV, l.u/UU,l.v/VV, m.u/UU,m.v/VV, h.u/UU,h.v/VV); // g,l,m,h
	//PY
  vertices.push(-WW/2,HH/2,-DD/2, -WW/2,HH/2,DD/2, WW/2,HH/2,DD/2, WW/2,HH/2,-DD/2 );  // 4 0 1 5
  indices.push (16,17,18, 16,18,19); // [0,1,2, 0,2,3] + 16
	uvs.push (a.u/UU,a.v/VV, e.u/UU,e.v/VV, f.u/UU,f.v/VV, b.u/UU,b.v/VV); // a,e,f,b
	//NY
  vertices.push(-WW/2,-HH/2,-DD/2, -WW/2,-HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,-HH/2,-DD/2 );  // 7 3 2 6
  indices.push (20,21,22, 20,22,23); // [0,1,2, 0,2,3] + 20
	uvs.push (b.u/UU,b.v/VV, f.u/UU,f.v/VV, g.u/UU,g.v/VV, c.u/UU,c.v/VV); // b,f,g,c

	geometry.setIndex(indices);  
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));	
	
  let head = new THREE.Mesh (geometry, new THREE.MeshBasicMaterial({map: texture, transparent: true, side:THREE.DoubleSide}));
	return head;
}

function buildBody(WW, HH, DD, texture) {
 
	var geometry = new THREE.BufferGeometry();	
  var vertices = [];
  var indices = [];
	var uvs = [];

  const ww = 1;
  const hh = 3;
	const UU = 16*ww;
  const VV = 3*hh + 7*ww;
  
  var a = {u: 5*ww, v:hh+ww+2*ww+2*hh};
  var b = {u: 7*ww, v:hh+ww+2*ww+2*hh};
  var c = {u: 9*ww, v:hh+ww+2*ww+2*hh};
  var d = {u: 4*ww, v:hh+2*ww+2*hh};
  var e = {u: 5*ww, v:hh+2*ww+2*hh};
  var f = {u: 7*ww, v:hh+2*ww+2*hh};
  var g = {u: 8*ww, v:hh+2*ww+2*hh};
  var h = {u: 10*ww, v:hh+2*ww+2*hh};
  var i = {u: 4*ww, v:0+2*ww+2*hh};
  var j = {u: 5*ww, v:0+2*ww+2*hh};
  var k = {u: 7*ww, v:0+2*ww+2*hh};
  var l = {u: 8*ww, v:0+2*ww+2*hh};
  var m = {u: 10*ww, v:0+2*ww+2*hh};
  var x = {u: 9*ww, v: hh+2*ww+2*hh};

	// PZ
  vertices.push(-WW/2,HH/2,DD/2, -WW/2,-HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,HH/2,DD/2 ); // 0,3,2,1
  indices.push(0,1,2, 0,2,3);
	uvs.push (e.u/UU,e.v/VV, j.u/UU,j.v/VV, k.u/UU,k.v/VV, f.u/UU,f.v/VV); // e,j,k,f

	// PX
  vertices.push(WW/2,HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,-HH/2,-DD/2, WW/2,HH/2,-DD/2 ); // 1,2,6,5
  indices.push (4,5,6, 4,6,7); // [0,1,2, 0,2,3] + 4
	uvs.push (f.u/UU,f.v/VV, k.u/UU,k.v/VV, l.u/UU,l.v/VV, g.u/UU,g.v/VV); // f,k,l,g
	
	// NX
  vertices.push(-WW/2,HH/2,-DD/2, -WW/2,-HH/2,-DD/2, -WW/2,-HH/2,DD/2, -WW/2,HH/2,DD/2 ); // 4,7,3,0
  indices.push (8,9,10, 8,10,11); // [0,1,2, 0,2,3] + 8
	uvs.push (d.u/UU,d.v/VV, i.u/UU,i.v/VV, j.u/UU,j.v/VV, e.u/UU,e.v/VV); // d,i,j,e

	// NZ
  vertices.push(WW/2,HH/2,-DD/2, WW/2,-HH/2,-DD/2, -WW/2,-HH/2,-DD/2, -WW/2,HH/2,-DD/2 ); // 5,6,7,4
  indices.push (12,13,14, 12,14,15); // [0,1,2, 0,2,3] + 12
	uvs.push (g.u/UU,g.v/VV, l.u/UU,l.v/VV, m.u/UU,m.v/VV, h.u/UU,h.v/VV); // g,l,m,h
	//PY
  vertices.push(-WW/2,HH/2,-DD/2, -WW/2,HH/2,DD/2, WW/2,HH/2,DD/2, WW/2,HH/2,-DD/2 );  // 4 0 1 5
  indices.push (16,17,18, 16,18,19); // [0,1,2, 0,2,3] + 16
	uvs.push (a.u/UU,a.v/VV, e.u/UU,e.v/VV, f.u/UU,f.v/VV, b.u/UU,b.v/VV); // a,e,f,b
	//NY
  vertices.push(-WW/2,-HH/2,-DD/2, -WW/2,-HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,-HH/2,-DD/2 );  // 7 3 2 6
  indices.push (20,21,22, 20,22,23); // [0,1,2, 0,2,3] + 20
	uvs.push (b.u/UU,b.v/VV, f.u/UU,f.v/VV, g.u/UU,g.v/VV, c.u/UU,c.v/VV); // b,f,g,c

	geometry.setIndex(indices);  
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));	
	
  let body = new THREE.Mesh (geometry, new THREE.MeshBasicMaterial({map: texture, transparent: true, side:THREE.DoubleSide}));
	return body;
}

function buildBodyArmor(WW, HH, DD, texture) {
 
	var geometry = new THREE.BufferGeometry();	
  var vertices = [];
  var indices = [];
	var uvs = [];

  const ww = 1;
  const hh = 3;
	const UU = 16*ww;
  const VV = 3*hh + 7*ww;
  
  var a = {u: 5*ww, v:hh+ww+ww+hh};
  var b = {u: 7*ww, v:hh+ww+ww+hh};
  var c = {u: 9*ww, v:hh+ww+ww+hh};
  var d = {u: 4*ww, v:hh+ww+hh};
  var e = {u: 5*ww, v:hh+ww+hh};
  var f = {u: 7*ww, v:hh+ww+hh};
  var g = {u: 8*ww, v:hh+ww+hh};
  var h = {u: 10*ww, v:hh+ww+hh};
  var i = {u: 4*ww, v:0+ww+hh};
  var j = {u: 5*ww, v:0+ww+hh};
  var k = {u: 7*ww, v:0+ww+hh};
  var l = {u: 8*ww, v:0+ww+hh};
  var m = {u: 10*ww, v:0+ww+hh};
  var x = {u: 9*ww, v: hh+ww+hh};

	// PZ
  vertices.push(-WW/2,HH/2,DD/2, -WW/2,-HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,HH/2,DD/2 ); // 0,3,2,1
  indices.push(0,1,2, 0,2,3);
	uvs.push (e.u/UU,e.v/VV, j.u/UU,j.v/VV, k.u/UU,k.v/VV, f.u/UU,f.v/VV); // e,j,k,f

	// PX
  vertices.push(WW/2,HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,-HH/2,-DD/2, WW/2,HH/2,-DD/2 ); // 1,2,6,5
  indices.push (4,5,6, 4,6,7); // [0,1,2, 0,2,3] + 4
	uvs.push (f.u/UU,f.v/VV, k.u/UU,k.v/VV, l.u/UU,l.v/VV, g.u/UU,g.v/VV); // f,k,l,g
	
	// NX
  vertices.push(-WW/2,HH/2,-DD/2, -WW/2,-HH/2,-DD/2, -WW/2,-HH/2,DD/2, -WW/2,HH/2,DD/2 ); // 4,7,3,0
  indices.push (8,9,10, 8,10,11); // [0,1,2, 0,2,3] + 8
	uvs.push (d.u/UU,d.v/VV, i.u/UU,i.v/VV, j.u/UU,j.v/VV, e.u/UU,e.v/VV); // d,i,j,e

	// NZ
  vertices.push(WW/2,HH/2,-DD/2, WW/2,-HH/2,-DD/2, -WW/2,-HH/2,-DD/2, -WW/2,HH/2,-DD/2 ); // 5,6,7,4
  indices.push (12,13,14, 12,14,15); // [0,1,2, 0,2,3] + 12
	uvs.push (g.u/UU,g.v/VV, l.u/UU,l.v/VV, m.u/UU,m.v/VV, h.u/UU,h.v/VV); // g,l,m,h
	//PY
  vertices.push(-WW/2,HH/2,-DD/2, -WW/2,HH/2,DD/2, WW/2,HH/2,DD/2, WW/2,HH/2,-DD/2 );  // 4 0 1 5
  indices.push (16,17,18, 16,18,19); // [0,1,2, 0,2,3] + 16
	uvs.push (a.u/UU,a.v/VV, e.u/UU,e.v/VV, f.u/UU,f.v/VV, b.u/UU,b.v/VV); // a,e,f,b
	//NY
  vertices.push(-WW/2,-HH/2,-DD/2, -WW/2,-HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,-HH/2,-DD/2 );  // 7 3 2 6
  indices.push (20,21,22, 20,22,23); // [0,1,2, 0,2,3] + 20
	uvs.push (b.u/UU,b.v/VV, f.u/UU,f.v/VV, g.u/UU,g.v/VV, c.u/UU,c.v/VV); // b,f,g,c

	geometry.setIndex(indices);  
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));	
	
  let body = new THREE.Mesh (geometry, new THREE.MeshBasicMaterial({map: texture, transparent: true, side:THREE.DoubleSide}));
	return body;
}

function buildArm1(WW, HH, DD, texture) {

  var geometry = new THREE.BufferGeometry();	
  var vertices = [];
  var indices = [];
  var uvs = [];
  const ww = 1;
  const hh = 3;
  const UU = 16*ww;
  const VV = 3*hh + 7*ww;
  
  var a = {u: ww+10*ww, v: hh+ww+(2*ww+2*hh)};
  var b = {u: 2*ww+10*ww, v: hh+ww+(2*ww+2*hh)};
  var c = {u: 3*ww+10*ww, v: hh+ww+(2*ww+2*hh)};
  var d = {u: 0+10*ww, v: hh+(2*ww+2*hh)};
  var e = {u: ww+10*ww, v: hh+(2*ww+2*hh)};
  var f = {u: 2*ww+10*ww, v: hh+(2*ww+2*hh)};
  var g = {u: 3*ww+10*ww, v: hh+(2*ww+2*hh)};
  var h = {u: 4*ww+10*ww, v: hh+(2*ww+2*hh)};
  var i = {u: 0+10*ww, v: (2*ww+2*hh)};
  var j = {u: ww+10*ww, v: (2*ww+2*hh)};
  var k = {u: 2*ww+10*ww, v: (2*ww+2*hh)};
  var l = {u: 3*ww+10*ww, v: (2*ww+2*hh)};
  var m = {u: 4*ww+10*ww, v: (2*ww+2*hh)};

  // PZ
  vertices.push(-WW/2,HH/2,DD/2, -WW/2,-HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,HH/2,DD/2 ); // 0,3,2,1
  indices.push(0,1,2, 0,2,3);
	uvs.push (e.u/UU,e.v/VV, j.u/UU,j.v/VV, k.u/UU,k.v/VV, f.u/UU,f.v/VV); // e,j,k,f

	// PX
  vertices.push(WW/2,HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,-HH/2,-DD/2, WW/2,HH/2,-DD/2 ); // 1,2,6,5
  indices.push (4,5,6, 4,6,7); // [0,1,2, 0,2,3] + 4
	uvs.push (f.u/UU,f.v/VV, k.u/UU,k.v/VV, l.u/UU,l.v/VV, g.u/UU,g.v/VV); // f,k,l,g
	
	// NX
  vertices.push(-WW/2,HH/2,-DD/2, -WW/2,-HH/2,-DD/2, -WW/2,-HH/2,DD/2, -WW/2,HH/2,DD/2 ); // 4,7,3,0
  indices.push (8,9,10, 8,10,11); // [0,1,2, 0,2,3] + 8
	uvs.push (d.u/UU,d.v/VV, i.u/UU,i.v/VV, j.u/UU,j.v/VV, e.u/UU,e.v/VV); // d,i,j,e

	// NZ
  vertices.push(WW/2,HH/2,-DD/2, WW/2,-HH/2,-DD/2, -WW/2,-HH/2,-DD/2, -WW/2,HH/2,-DD/2 ); // 5,6,7,4
  indices.push (12,13,14, 12,14,15); // [0,1,2, 0,2,3] + 12
	uvs.push (g.u/UU,g.v/VV, l.u/UU,l.v/VV, m.u/UU,m.v/VV, h.u/UU,h.v/VV); // g,l,m,h
	//PY
  vertices.push(-WW/2,HH/2,-DD/2, -WW/2,HH/2,DD/2, WW/2,HH/2,DD/2, WW/2,HH/2,-DD/2 );  // 4 0 1 5
  indices.push (16,17,18, 16,18,19); // [0,1,2, 0,2,3] + 16
	uvs.push (a.u/UU,a.v/VV, e.u/UU,e.v/VV, f.u/UU,f.v/VV, b.u/UU,b.v/VV); // a,e,f,b
	//NY
  vertices.push(-WW/2,-HH/2,-DD/2, -WW/2,-HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,-HH/2,-DD/2 );  // 7 3 2 6
  indices.push (20,21,22, 20,22,23); // [0,1,2, 0,2,3] + 20
	uvs.push (b.u/UU,b.v/VV, f.u/UU,f.v/VV, g.u/UU,g.v/VV, c.u/UU,c.v/VV); // b,f,g,c

	geometry.setIndex(indices);  
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));	
	
  let head = new THREE.Mesh (geometry, new THREE.MeshBasicMaterial({map: texture, transparent: false, side:THREE.DoubleSide}));
	return head;
}

function buildArm1Armor(WW, HH, DD, texture) {

  var geometry = new THREE.BufferGeometry();	
  var vertices = [];
  var indices = [];
  var uvs = [];
  const ww = 1;
  const hh = 3;
  const UU = 16*ww;
  const VV = 3*hh + 7*ww;
  
  var a = {u: ww+10*ww, v: hh+ww+(ww+hh)};
  var b = {u: 2*ww+10*ww, v: hh+ww+(ww+hh)};
  var c = {u: 3*ww+10*ww, v: hh+ww+(ww+hh)};
  var d = {u: 0+10*ww, v: hh+(ww+hh)};
  var e = {u: ww+10*ww, v: hh+(ww+hh)};
  var f = {u: 2*ww+10*ww, v: hh+(ww+hh)};
  var g = {u: 3*ww+10*ww, v: hh+(ww+hh)};
  var h = {u: 4*ww+10*ww, v: hh+(ww+hh)};
  var i = {u: 0+10*ww, v: (ww+hh)};
  var j = {u: ww+10*ww, v: (ww+hh)};
  var k = {u: 2*ww+10*ww, v: (ww+hh)};
  var l = {u: 3*ww+10*ww, v: (ww+hh)};
  var m = {u: 4*ww+10*ww, v: (ww+hh)};

  // PZ
  vertices.push(-WW/2,HH/2,DD/2, -WW/2,-HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,HH/2,DD/2 ); // 0,3,2,1
  indices.push(0,1,2, 0,2,3);
	uvs.push (e.u/UU,e.v/VV, j.u/UU,j.v/VV, k.u/UU,k.v/VV, f.u/UU,f.v/VV); // e,j,k,f

	// PX
  vertices.push(WW/2,HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,-HH/2,-DD/2, WW/2,HH/2,-DD/2 ); // 1,2,6,5
  indices.push (4,5,6, 4,6,7); // [0,1,2, 0,2,3] + 4
	uvs.push (f.u/UU,f.v/VV, k.u/UU,k.v/VV, l.u/UU,l.v/VV, g.u/UU,g.v/VV); // f,k,l,g
	
	// NX
  vertices.push(-WW/2,HH/2,-DD/2, -WW/2,-HH/2,-DD/2, -WW/2,-HH/2,DD/2, -WW/2,HH/2,DD/2 ); // 4,7,3,0
  indices.push (8,9,10, 8,10,11); // [0,1,2, 0,2,3] + 8
	uvs.push (d.u/UU,d.v/VV, i.u/UU,i.v/VV, j.u/UU,j.v/VV, e.u/UU,e.v/VV); // d,i,j,e

	// NZ
  vertices.push(WW/2,HH/2,-DD/2, WW/2,-HH/2,-DD/2, -WW/2,-HH/2,-DD/2, -WW/2,HH/2,-DD/2 ); // 5,6,7,4
  indices.push (12,13,14, 12,14,15); // [0,1,2, 0,2,3] + 12
	uvs.push (g.u/UU,g.v/VV, l.u/UU,l.v/VV, m.u/UU,m.v/VV, h.u/UU,h.v/VV); // g,l,m,h
	//PY
  vertices.push(-WW/2,HH/2,-DD/2, -WW/2,HH/2,DD/2, WW/2,HH/2,DD/2, WW/2,HH/2,-DD/2 );  // 4 0 1 5
  indices.push (16,17,18, 16,18,19); // [0,1,2, 0,2,3] + 16
	uvs.push (a.u/UU,a.v/VV, e.u/UU,e.v/VV, f.u/UU,f.v/VV, b.u/UU,b.v/VV); // a,e,f,b
	//NY
  vertices.push(-WW/2,-HH/2,-DD/2, -WW/2,-HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,-HH/2,-DD/2 );  // 7 3 2 6
  indices.push (20,21,22, 20,22,23); // [0,1,2, 0,2,3] + 20
	uvs.push (b.u/UU,b.v/VV, f.u/UU,f.v/VV, g.u/UU,g.v/VV, c.u/UU,c.v/VV); // b,f,g,c

	geometry.setIndex(indices);  
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));	
	
  let head = new THREE.Mesh (geometry, new THREE.MeshBasicMaterial({map: texture, transparent: true, side:THREE.DoubleSide}));
	return head;
}

function buildArm2(WW, HH, DD, texture) {

  var geometry = new THREE.BufferGeometry();	
  var vertices = [];
  var indices = [];
  var uvs = [];
  const ww = 1;
  const hh = 3;
  const UU = 16*ww;
  const VV = 3*hh + 7*ww;
  
  var a = {u: ww+8*ww, v: hh+ww};
  var b = {u: 2*ww+8*ww, v: hh+ww};
  var c = {u: 3*ww+8*ww, v: hh+ww};
  var d = {u: 0+8*ww, v: hh};
  var e = {u: ww+8*ww, v: hh};
  var f = {u: 2*ww+8*ww, v: hh};
  var g = {u: 3*ww+8*ww, v: hh};
  var h = {u: 4*ww+8*ww, v: hh};
  var i = {u: 0+8*ww, v: 0};
  var j = {u: ww+8*ww, v: 0};
  var k = {u: 2*ww+8*ww, v: 0};
  var l = {u: 3*ww+8*ww, v: 0};
  var m = {u: 4*ww+8*ww, v: 0};

  // PZ
  vertices.push(-WW/2,HH/2,DD/2, -WW/2,-HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,HH/2,DD/2 ); // 0,3,2,1
  indices.push(0,1,2, 0,2,3);
	uvs.push (e.u/UU,e.v/VV, j.u/UU,j.v/VV, k.u/UU,k.v/VV, f.u/UU,f.v/VV); // e,j,k,f

	// PX
  vertices.push(WW/2,HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,-HH/2,-DD/2, WW/2,HH/2,-DD/2 ); // 1,2,6,5
  indices.push (4,5,6, 4,6,7); // [0,1,2, 0,2,3] + 4
	uvs.push (f.u/UU,f.v/VV, k.u/UU,k.v/VV, l.u/UU,l.v/VV, g.u/UU,g.v/VV); // f,k,l,g
	
	// NX
  vertices.push(-WW/2,HH/2,-DD/2, -WW/2,-HH/2,-DD/2, -WW/2,-HH/2,DD/2, -WW/2,HH/2,DD/2 ); // 4,7,3,0
  indices.push (8,9,10, 8,10,11); // [0,1,2, 0,2,3] + 8
	uvs.push (d.u/UU,d.v/VV, i.u/UU,i.v/VV, j.u/UU,j.v/VV, e.u/UU,e.v/VV); // d,i,j,e

	// NZ
  vertices.push(WW/2,HH/2,-DD/2, WW/2,-HH/2,-DD/2, -WW/2,-HH/2,-DD/2, -WW/2,HH/2,-DD/2 ); // 5,6,7,4
  indices.push (12,13,14, 12,14,15); // [0,1,2, 0,2,3] + 12
	uvs.push (g.u/UU,g.v/VV, l.u/UU,l.v/VV, m.u/UU,m.v/VV, h.u/UU,h.v/VV); // g,l,m,h
	//PY
  vertices.push(-WW/2,HH/2,-DD/2, -WW/2,HH/2,DD/2, WW/2,HH/2,DD/2, WW/2,HH/2,-DD/2 );  // 4 0 1 5
  indices.push (16,17,18, 16,18,19); // [0,1,2, 0,2,3] + 16
	uvs.push (a.u/UU,a.v/VV, e.u/UU,e.v/VV, f.u/UU,f.v/VV, b.u/UU,b.v/VV); // a,e,f,b
	//NY
  vertices.push(-WW/2,-HH/2,-DD/2, -WW/2,-HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,-HH/2,-DD/2 );  // 7 3 2 6
  indices.push (20,21,22, 20,22,23); // [0,1,2, 0,2,3] + 20
	uvs.push (b.u/UU,b.v/VV, f.u/UU,f.v/VV, g.u/UU,g.v/VV, c.u/UU,c.v/VV); // b,f,g,c

	geometry.setIndex(indices);  
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));	
	
  let head = new THREE.Mesh (geometry, new THREE.MeshBasicMaterial({map: texture, transparent: true, side:THREE.DoubleSide}));
	return head;
}

function buildArm2Armor(WW, HH, DD, texture) {

  var geometry = new THREE.BufferGeometry();	
  var vertices = [];
  var indices = [];
  var uvs = [];
  const ww = 1;
  const hh = 3;
  const UU = 16*ww;
  const VV = 3*hh + 7*ww;
  
  var a = {u: ww+12*ww, v: hh+ww};
  var b = {u: 2*ww+12*ww, v: hh+ww};
  var c = {u: 3*ww+12*ww, v: hh+ww};
  var d = {u: 0+12*ww, v: hh};
  var e = {u: ww+12*ww, v: hh};
  var f = {u: 2*ww+12*ww, v: hh};
  var g = {u: 3*ww+12*ww, v: hh};
  var h = {u: 4*ww+12*ww, v: hh};
  var i = {u: 0+12*ww, v: 0};
  var j = {u: ww+12*ww, v: 0};
  var k = {u: 2*ww+12*ww, v: 0};
  var l = {u: 3*ww+12*ww, v: 0};
  var m = {u: 4*ww+12*ww, v: 0};

  // PZ
  vertices.push(-WW/2,HH/2,DD/2, -WW/2,-HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,HH/2,DD/2 ); // 0,3,2,1
  indices.push(0,1,2, 0,2,3);
	uvs.push (e.u/UU,e.v/VV, j.u/UU,j.v/VV, k.u/UU,k.v/VV, f.u/UU,f.v/VV); // e,j,k,f

	// PX
  vertices.push(WW/2,HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,-HH/2,-DD/2, WW/2,HH/2,-DD/2 ); // 1,2,6,5
  indices.push (4,5,6, 4,6,7); // [0,1,2, 0,2,3] + 4
	uvs.push (f.u/UU,f.v/VV, k.u/UU,k.v/VV, l.u/UU,l.v/VV, g.u/UU,g.v/VV); // f,k,l,g
	
	// NX
  vertices.push(-WW/2,HH/2,-DD/2, -WW/2,-HH/2,-DD/2, -WW/2,-HH/2,DD/2, -WW/2,HH/2,DD/2 ); // 4,7,3,0
  indices.push (8,9,10, 8,10,11); // [0,1,2, 0,2,3] + 8
	uvs.push (d.u/UU,d.v/VV, i.u/UU,i.v/VV, j.u/UU,j.v/VV, e.u/UU,e.v/VV); // d,i,j,e

	// NZ
  vertices.push(WW/2,HH/2,-DD/2, WW/2,-HH/2,-DD/2, -WW/2,-HH/2,-DD/2, -WW/2,HH/2,-DD/2 ); // 5,6,7,4
  indices.push (12,13,14, 12,14,15); // [0,1,2, 0,2,3] + 12
	uvs.push (g.u/UU,g.v/VV, l.u/UU,l.v/VV, m.u/UU,m.v/VV, h.u/UU,h.v/VV); // g,l,m,h
	//PY
  vertices.push(-WW/2,HH/2,-DD/2, -WW/2,HH/2,DD/2, WW/2,HH/2,DD/2, WW/2,HH/2,-DD/2 );  // 4 0 1 5
  indices.push (16,17,18, 16,18,19); // [0,1,2, 0,2,3] + 16
	uvs.push (a.u/UU,a.v/VV, e.u/UU,e.v/VV, f.u/UU,f.v/VV, b.u/UU,b.v/VV); // a,e,f,b
	//NY
  vertices.push(-WW/2,-HH/2,-DD/2, -WW/2,-HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,-HH/2,-DD/2 );  // 7 3 2 6
  indices.push (20,21,22, 20,22,23); // [0,1,2, 0,2,3] + 20
	uvs.push (b.u/UU,b.v/VV, f.u/UU,f.v/VV, g.u/UU,g.v/VV, c.u/UU,c.v/VV); // b,f,g,c

	geometry.setIndex(indices);  
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));	
	
  let head = new THREE.Mesh (geometry, new THREE.MeshBasicMaterial({map: texture, transparent: true, side:THREE.DoubleSide}));
	return head;
}

function buildLeg1(WW, HH, DD, texture) {

  var geometry = new THREE.BufferGeometry();	
  var vertices = [];
  var indices = [];
  var uvs = [];
  const ww = 1;
  const hh = 3;
  const UU = 16*ww;
  const VV = 3*hh + 7*ww;
  
  var a = {u: ww, v: hh+ww+(2*ww+2*hh)};
  var b = {u: 2*ww, v: hh+ww+(2*ww+2*hh)};
  var c = {u: 3*ww, v: hh+ww+(2*ww+2*hh)};
  var d = {u: 0, v: hh+(2*ww+2*hh)};
  var e = {u: ww, v: hh+(2*ww+2*hh)};
  var f = {u: 2*ww, v: hh+(2*ww+2*hh)};
  var g = {u: 3*ww, v: hh+(2*ww+2*hh)};
  var h = {u: 4*ww, v: hh+(2*ww+2*hh)};
  var i = {u: 0, v: (2*ww+2*hh)};
  var j = {u: ww, v: (2*ww+2*hh)};
  var k = {u: 2*ww, v: (2*ww+2*hh)};
  var l = {u: 3*ww, v: (2*ww+2*hh)};
  var m = {u: 4*ww, v: (2*ww+2*hh)};

  // PZ
  vertices.push(-WW/2,HH/2,DD/2, -WW/2,-HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,HH/2,DD/2 ); // 0,3,2,1
  indices.push(0,1,2, 0,2,3);
	uvs.push (e.u/UU,e.v/VV, j.u/UU,j.v/VV, k.u/UU,k.v/VV, f.u/UU,f.v/VV); // e,j,k,f

	// PX
  vertices.push(WW/2,HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,-HH/2,-DD/2, WW/2,HH/2,-DD/2 ); // 1,2,6,5
  indices.push (4,5,6, 4,6,7); // [0,1,2, 0,2,3] + 4
	uvs.push (f.u/UU,f.v/VV, k.u/UU,k.v/VV, l.u/UU,l.v/VV, g.u/UU,g.v/VV); // f,k,l,g
	
	// NX
  vertices.push(-WW/2,HH/2,-DD/2, -WW/2,-HH/2,-DD/2, -WW/2,-HH/2,DD/2, -WW/2,HH/2,DD/2 ); // 4,7,3,0
  indices.push (8,9,10, 8,10,11); // [0,1,2, 0,2,3] + 8
	uvs.push (d.u/UU,d.v/VV, i.u/UU,i.v/VV, j.u/UU,j.v/VV, e.u/UU,e.v/VV); // d,i,j,e

	// NZ
  vertices.push(WW/2,HH/2,-DD/2, WW/2,-HH/2,-DD/2, -WW/2,-HH/2,-DD/2, -WW/2,HH/2,-DD/2 ); // 5,6,7,4
  indices.push (12,13,14, 12,14,15); // [0,1,2, 0,2,3] + 12
	uvs.push (g.u/UU,g.v/VV, l.u/UU,l.v/VV, m.u/UU,m.v/VV, h.u/UU,h.v/VV); // g,l,m,h
	//PY
  vertices.push(-WW/2,HH/2,-DD/2, -WW/2,HH/2,DD/2, WW/2,HH/2,DD/2, WW/2,HH/2,-DD/2 );  // 4 0 1 5
  indices.push (16,17,18, 16,18,19); // [0,1,2, 0,2,3] + 16
	uvs.push (a.u/UU,a.v/VV, e.u/UU,e.v/VV, f.u/UU,f.v/VV, b.u/UU,b.v/VV); // a,e,f,b
	//NY
  vertices.push(-WW/2,-HH/2,-DD/2, -WW/2,-HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,-HH/2,-DD/2 );  // 7 3 2 6
  indices.push (20,21,22, 20,22,23); // [0,1,2, 0,2,3] + 20
	uvs.push (b.u/UU,b.v/VV, f.u/UU,f.v/VV, g.u/UU,g.v/VV, c.u/UU,c.v/VV); // b,f,g,c

	geometry.setIndex(indices);  
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));	
	
  let head = new THREE.Mesh (geometry, new THREE.MeshBasicMaterial({map: texture, transparent: true, side:THREE.DoubleSide}));
	return head;
}

function buildLeg2(WW, HH, DD, texture) {

  var geometry = new THREE.BufferGeometry();	
  var vertices = [];
  var indices = [];
  var uvs = [];
  const ww = 1;
  const hh = 3;
  const UU = 16*ww;
  const VV = 3*hh + 7*ww;
  
  var a = {u: ww+4*ww, v: hh+ww};
  var b = {u: 2*ww+4*ww, v: hh+ww};
  var c = {u: 3*ww+4*ww, v: hh+ww};
  var d = {u: 0+4*ww, v: hh};
  var e = {u: ww+4*ww, v: hh};
  var f = {u: 2*ww+4*ww, v: hh};
  var g = {u: 3*ww+4*ww, v: hh};
  var h = {u: 4*ww+4*ww, v: hh};
  var i = {u: 0+4*ww, v: 0};
  var j = {u: ww+4*ww, v: 0};
  var k = {u: 2*ww+4*ww, v: 0};
  var l = {u: 3*ww+4*ww, v: 0};
  var m = {u: 4*ww+4*ww, v: 0};

  // PZ
  vertices.push(-WW/2,HH/2,DD/2, -WW/2,-HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,HH/2,DD/2 ); // 0,3,2,1
  indices.push(0,1,2, 0,2,3);
	uvs.push (e.u/UU,e.v/VV, j.u/UU,j.v/VV, k.u/UU,k.v/VV, f.u/UU,f.v/VV); // e,j,k,f

	// PX
  vertices.push(WW/2,HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,-HH/2,-DD/2, WW/2,HH/2,-DD/2 ); // 1,2,6,5
  indices.push (4,5,6, 4,6,7); // [0,1,2, 0,2,3] + 4
	uvs.push (f.u/UU,f.v/VV, k.u/UU,k.v/VV, l.u/UU,l.v/VV, g.u/UU,g.v/VV); // f,k,l,g
	
	// NX
  vertices.push(-WW/2,HH/2,-DD/2, -WW/2,-HH/2,-DD/2, -WW/2,-HH/2,DD/2, -WW/2,HH/2,DD/2 ); // 4,7,3,0
  indices.push (8,9,10, 8,10,11); // [0,1,2, 0,2,3] + 8
	uvs.push (d.u/UU,d.v/VV, i.u/UU,i.v/VV, j.u/UU,j.v/VV, e.u/UU,e.v/VV); // d,i,j,e

	// NZ
  vertices.push(WW/2,HH/2,-DD/2, WW/2,-HH/2,-DD/2, -WW/2,-HH/2,-DD/2, -WW/2,HH/2,-DD/2 ); // 5,6,7,4
  indices.push (12,13,14, 12,14,15); // [0,1,2, 0,2,3] + 12
	uvs.push (g.u/UU,g.v/VV, l.u/UU,l.v/VV, m.u/UU,m.v/VV, h.u/UU,h.v/VV); // g,l,m,h
	//PY
  vertices.push(-WW/2,HH/2,-DD/2, -WW/2,HH/2,DD/2, WW/2,HH/2,DD/2, WW/2,HH/2,-DD/2 );  // 4 0 1 5
  indices.push (16,17,18, 16,18,19); // [0,1,2, 0,2,3] + 16
	uvs.push (a.u/UU,a.v/VV, e.u/UU,e.v/VV, f.u/UU,f.v/VV, b.u/UU,b.v/VV); // a,e,f,b
	//NY
  vertices.push(-WW/2,-HH/2,-DD/2, -WW/2,-HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,-HH/2,-DD/2 );  // 7 3 2 6
  indices.push (20,21,22, 20,22,23); // [0,1,2, 0,2,3] + 20
	uvs.push (b.u/UU,b.v/VV, f.u/UU,f.v/VV, g.u/UU,g.v/VV, c.u/UU,c.v/VV); // b,f,g,c

	geometry.setIndex(indices);  
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));	
	
  let head = new THREE.Mesh (geometry, new THREE.MeshBasicMaterial({map: texture, transparent: true, side:THREE.DoubleSide}));
	return head;
}

function buildLeg1Armor(WW, HH, DD, texture) { //右腿

  var geometry = new THREE.BufferGeometry();	
  var vertices = [];
  var indices = [];
  var uvs = [];
  const ww = 1;
  const hh = 3;
  const UU = 16*ww;
  const VV = 3*hh + 7*ww;
  
  var a = {u: ww, v: hh+ww+(ww+hh)};
  var b = {u: 2*ww, v: hh+ww+(ww+hh)};
  var c = {u: 3*ww, v: hh+ww+(ww+hh)};
  var d = {u: 0, v: hh+(ww+hh)};
  var e = {u: ww, v: hh+(ww+hh)};
  var f = {u: 2*ww, v: hh+(ww+hh)};
  var g = {u: 3*ww, v: hh+(ww+hh)};
  var h = {u: 4*ww, v: hh+(ww+hh)};
  var i = {u: 0, v: (ww+hh)};
  var j = {u: ww, v: (ww+hh)};
  var k = {u: 2*ww, v: (ww+hh)};
  var l = {u: 3*ww, v: (ww+hh)};
  var m = {u: 4*ww, v: (ww+hh)};

  // PZ
  vertices.push(-WW/2,HH/2,DD/2, -WW/2,-HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,HH/2,DD/2 ); // 0,3,2,1
  indices.push(0,1,2, 0,2,3);
	uvs.push (e.u/UU,e.v/VV, j.u/UU,j.v/VV, k.u/UU,k.v/VV, f.u/UU,f.v/VV); // e,j,k,f

	// PX
  vertices.push(WW/2,HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,-HH/2,-DD/2, WW/2,HH/2,-DD/2 ); // 1,2,6,5
  indices.push (4,5,6, 4,6,7); // [0,1,2, 0,2,3] + 4
	uvs.push (f.u/UU,f.v/VV, k.u/UU,k.v/VV, l.u/UU,l.v/VV, g.u/UU,g.v/VV); // f,k,l,g
	
	// NX
  vertices.push(-WW/2,HH/2,-DD/2, -WW/2,-HH/2,-DD/2, -WW/2,-HH/2,DD/2, -WW/2,HH/2,DD/2 ); // 4,7,3,0
  indices.push (8,9,10, 8,10,11); // [0,1,2, 0,2,3] + 8
	uvs.push (d.u/UU,d.v/VV, i.u/UU,i.v/VV, j.u/UU,j.v/VV, e.u/UU,e.v/VV); // d,i,j,e

	// NZ
  vertices.push(WW/2,HH/2,-DD/2, WW/2,-HH/2,-DD/2, -WW/2,-HH/2,-DD/2, -WW/2,HH/2,-DD/2 ); // 5,6,7,4
  indices.push (12,13,14, 12,14,15); // [0,1,2, 0,2,3] + 12
	uvs.push (g.u/UU,g.v/VV, l.u/UU,l.v/VV, m.u/UU,m.v/VV, h.u/UU,h.v/VV); // g,l,m,h
	//PY
  vertices.push(-WW/2,HH/2,-DD/2, -WW/2,HH/2,DD/2, WW/2,HH/2,DD/2, WW/2,HH/2,-DD/2 );  // 4 0 1 5
  indices.push (16,17,18, 16,18,19); // [0,1,2, 0,2,3] + 16
	uvs.push (a.u/UU,a.v/VV, e.u/UU,e.v/VV, f.u/UU,f.v/VV, b.u/UU,b.v/VV); // a,e,f,b
	//NY
  vertices.push(-WW/2,-HH/2,-DD/2, -WW/2,-HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,-HH/2,-DD/2 );  // 7 3 2 6
  indices.push (20,21,22, 20,22,23); // [0,1,2, 0,2,3] + 20
	uvs.push (b.u/UU,b.v/VV, f.u/UU,f.v/VV, g.u/UU,g.v/VV, c.u/UU,c.v/VV); // b,f,g,c

	geometry.setIndex(indices);  
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));	
	
  let head = new THREE.Mesh (geometry, new THREE.MeshBasicMaterial({map: texture, transparent: true, side:THREE.DoubleSide}));
	return head;
}

function buildLeg2Armor(WW, HH, DD, texture) { //左腿

  var geometry = new THREE.BufferGeometry();	
  var vertices = [];
  var indices = [];
  var uvs = [];
  const ww = 1;
  const hh = 3;
  const UU = 16*ww;
  const VV = 3*hh + 7*ww;
  
  var a = {u: ww, v: hh+ww};
  var b = {u: 2*ww, v: hh+ww};
  var c = {u: 3*ww, v: hh+ww};
  var d = {u: 0, v: hh};
  var e = {u: ww, v: hh};
  var f = {u: 2*ww, v: hh};
  var g = {u: 3*ww, v: hh};
  var h = {u: 4*ww, v: hh};
  var i = {u: 0, v: 0};
  var j = {u: ww, v: 0};
  var k = {u: 2*ww, v: 0};
  var l = {u: 3*ww, v: 0};
  var m = {u: 4*ww, v: 0};

  // PZ
  vertices.push(-WW/2,HH/2,DD/2, -WW/2,-HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,HH/2,DD/2 ); // 0,3,2,1
  indices.push(0,1,2, 0,2,3);
	uvs.push (e.u/UU,e.v/VV, j.u/UU,j.v/VV, k.u/UU,k.v/VV, f.u/UU,f.v/VV); // e,j,k,f

	// PX
  vertices.push(WW/2,HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,-HH/2,-DD/2, WW/2,HH/2,-DD/2 ); // 1,2,6,5
  indices.push (4,5,6, 4,6,7); // [0,1,2, 0,2,3] + 4
	uvs.push (f.u/UU,f.v/VV, k.u/UU,k.v/VV, l.u/UU,l.v/VV, g.u/UU,g.v/VV); // f,k,l,g
	
	// NX
  vertices.push(-WW/2,HH/2,-DD/2, -WW/2,-HH/2,-DD/2, -WW/2,-HH/2,DD/2, -WW/2,HH/2,DD/2 ); // 4,7,3,0
  indices.push (8,9,10, 8,10,11); // [0,1,2, 0,2,3] + 8
	uvs.push (d.u/UU,d.v/VV, i.u/UU,i.v/VV, j.u/UU,j.v/VV, e.u/UU,e.v/VV); // d,i,j,e

	// NZ
  vertices.push(WW/2,HH/2,-DD/2, WW/2,-HH/2,-DD/2, -WW/2,-HH/2,-DD/2, -WW/2,HH/2,-DD/2 ); // 5,6,7,4
  indices.push (12,13,14, 12,14,15); // [0,1,2, 0,2,3] + 12
	uvs.push (g.u/UU,g.v/VV, l.u/UU,l.v/VV, m.u/UU,m.v/VV, h.u/UU,h.v/VV); // g,l,m,h
	//PY
  vertices.push(-WW/2,HH/2,-DD/2, -WW/2,HH/2,DD/2, WW/2,HH/2,DD/2, WW/2,HH/2,-DD/2 );  // 4 0 1 5
  indices.push (16,17,18, 16,18,19); // [0,1,2, 0,2,3] + 16
	uvs.push (a.u/UU,a.v/VV, e.u/UU,e.v/VV, f.u/UU,f.v/VV, b.u/UU,b.v/VV); // a,e,f,b
	//NY
  vertices.push(-WW/2,-HH/2,-DD/2, -WW/2,-HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,-HH/2,-DD/2 );  // 7 3 2 6
  indices.push (20,21,22, 20,22,23); // [0,1,2, 0,2,3] + 20
	uvs.push (b.u/UU,b.v/VV, f.u/UU,f.v/VV, g.u/UU,g.v/VV, c.u/UU,c.v/VV); // b,f,g,c

	geometry.setIndex(indices);  
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));	
	
  let head = new THREE.Mesh (geometry, new THREE.MeshBasicMaterial({map: texture, transparent: true, side:THREE.DoubleSide}));
	return head;
}

function buildGrass(WW, HH, DD) { 

  var geometry = new THREE.BufferGeometry();	
  var vertices = [];
  var indices = [];
  var uvs = [];
  const ww = 1;
  const hh = 1;
  const UU = 4*ww;
  const VV = 3*hh;
  
  var a = {u: ww, v: 3*hh};
  var b = {u: 2*ww, v: 3*hh};
  var c = {u: 0, v: 2*hh};
  var d = {u: ww, v: 2*hh};
  var e = {u: 2*ww, v: 2*hh};
  var f = {u: 3*ww, v: 2*hh};
  var g = {u: 4*ww, v: 2*hh};
  var h = {u: 0, v: hh};
  var i = {u: ww, v: hh};
  var j = {u: 2*ww, v: hh};
  var k = {u: 3*ww, v: hh};
  var l = {u: 4*ww, v: hh};
  var m = {u: ww, v: 0};
  var n = {u: 2*ww, v: 0};

  // PZ
  vertices.push(-WW/2,HH/2,DD/2, -WW/2,-HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,HH/2,DD/2 ); // 0,3,2,1
  indices.push(0,1,2, 0,2,3);
	uvs.push (d.u/UU,d.v/VV, i.u/UU,i.v/VV, j.u/UU,j.v/VV, e.u/UU,e.v/VV); // d,i,j,e

	// PX
  vertices.push(WW/2,HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,-HH/2,-DD/2, WW/2,HH/2,-DD/2 ); // 1,2,6,5
  indices.push (4,5,6, 4,6,7); // [0,1,2, 0,2,3] + 4
	uvs.push (e.u/UU,e.v/VV, j.u/UU,j.v/VV, k.u/UU,k.v/VV, f.u/UU,f.v/VV); // e,j,k,f
	
	// NX
  vertices.push(-WW/2,HH/2,-DD/2, -WW/2,-HH/2,-DD/2, -WW/2,-HH/2,DD/2, -WW/2,HH/2,DD/2 ); // 4,7,3,0
  indices.push (8,9,10, 8,10,11); // [0,1,2, 0,2,3] + 8
	uvs.push (f.u/UU,f.v/VV, k.u/UU,k.v/VV, l.u/UU,l.v/VV, g.u/UU,g.v/VV); // f,k,l,g

	// NZ
  vertices.push(WW/2,HH/2,-DD/2, WW/2,-HH/2,-DD/2, -WW/2,-HH/2,-DD/2, -WW/2,HH/2,-DD/2 ); // 5,6,7,4
  indices.push (12,13,14, 12,14,15); // [0,1,2, 0,2,3] + 12
	uvs.push (c.u/UU,c.v/VV, h.u/UU,h.v/VV, i.u/UU,i.v/VV, d.u/UU,d.v/VV); // c,h,i,d
	//PY
  vertices.push(-WW/2,HH/2,-DD/2, -WW/2,HH/2,DD/2, WW/2,HH/2,DD/2, WW/2,HH/2,-DD/2 );  // 4 0 1 5
  indices.push (16,17,18, 16,18,19); // [0,1,2, 0,2,3] + 16
	uvs.push (a.u/UU,a.v/VV, d.u/UU,d.v/VV, e.u/UU,e.v/VV, b.u/UU,b.v/VV); // a,d,e,b
	//NY
  vertices.push(-WW/2,-HH/2,-DD/2, -WW/2,-HH/2,DD/2, WW/2,-HH/2,DD/2, WW/2,-HH/2,-DD/2 );  // 7 3 2 6
  indices.push (20,21,22, 20,22,23); // [0,1,2, 0,2,3] + 20
	uvs.push (i.u/UU,i.v/VV, m.u/UU,m.v/VV, n.u/UU,n.v/VV, j.u/UU,j.v/VV); // i,m,n,j

	geometry.setIndex(indices);  
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));	
	
  let head = new THREE.Mesh (geometry, new THREE.MeshBasicMaterial({map: grasstexture, transparent: true, side:THREE.DoubleSide}));
	return head;
}

function buildBackground(){
  let material = new THREE.MeshBasicMaterial({
    side: THREE.DoubleSide,
    transparent: true, // key to cutout texture
    map: treemap
  });
  tree = new THREE.Mesh(new THREE.PlaneGeometry(80, 80), material);
  tree.position.set(30,35,50)
  scene.add(tree);
}

function buildPart(texture) {
  let colorName = 'white'
  let torso = new THREE.Object3D();
  /*let normalMat = new THREE.MeshPhongMaterial({
    color: colorName,
    transparent: true,
    opacity: 0.64
  });*/
  let torsoMesh = buildBody(4,6,2,texture);
  torso.add(torsoMesh)
  torsoMesh.position.y = 9.5
  let upperArm = new THREE.Object3D()
  let upperArmMesh = buildArm1(2,6,2,texture)
  upperArmMesh.position.x = -6
  upperArmMesh.position.y = -3
  upperArm.add(upperArmMesh)
  let upperArmb = new THREE.Object3D()
  let upperArmbMesh = buildArm2(2,6,2,texture)
  upperArmbMesh.position.x = -6
  upperArmbMesh.position.y = -3
  upperArmb.add(upperArmbMesh)
  let leg = new THREE.Object3D()
  let legMesh = buildLeg1(2,6,2,texture)
  leg.add(legMesh)
  legMesh.position.x = -6
  legMesh.position.y = -3
  let legb = new THREE.Object3D()
  let legMeshb = buildLeg2(2,6,2,texture)
  legb.add(legMeshb)
  legMeshb.position.x = -6
  legMeshb.position.y = -3
  let head = new THREE.Object3D()
  let headMesh = buildHead(4,4,4,texture)
  head.add(headMesh)
  
  let headarmor = new THREE.Object3D()
  let headarmorMesh = buildHeadArmor(4.25,4.25,4.25,texture)
  headarmor.add(headarmorMesh)
  let bodyarmor = new THREE.Object3D()
  let bodyarmorMesh = buildBodyArmor(4.25,6.25,2.25,texture)
  bodyarmor.add(bodyarmorMesh)
  let upperArmarmor = new THREE.Object3D()
  let upperArmarmorMesh = buildArm1Armor(2.25,6.25,2.25,texture)
  upperArmarmorMesh.position.x = -6
  upperArmarmorMesh.position.y = -3
  upperArmarmor.add(upperArmarmorMesh)
  let upperArmbarmor = new THREE.Object3D()
  let upperArmbarmorMesh = buildArm2Armor(2.25,6.25,2.25,texture)
  upperArmbarmorMesh.position.x = -6
  upperArmbarmorMesh.position.y = -3
  upperArmbarmor.add(upperArmbarmorMesh)
  let legarmor = new THREE.Object3D()
  let legarmorMesh = buildLeg1Armor(2.25,6.25,2.25,texture)
  legarmor.add(legarmorMesh)
  legarmorMesh.position.x = -6
  legarmorMesh.position.y = -3
  let legbarmor = new THREE.Object3D()
  let legbarmorMesh = buildLeg2Armor(2.25,6.25,2.25,texture)
  legbarmor.add(legbarmorMesh)
  legbarmorMesh.position.x = -6
  legbarmorMesh.position.y = -3

  return [torso, upperArm, upperArmb, leg, legb, head, headarmor, bodyarmor, upperArmarmor, upperArmbarmor, legarmor, legbarmor];
}

function onWindowResize() {
  var width = window.innerWidth;
  var height = window.innerHeight;
  camera.aspect = width / height;
  camera.updateProjectionMatrix();
  renderer.setSize(width, height);
}

function makeCameraHelper() {
  var cameraModel = new THREE.Group();
  var body = new THREE.Mesh (new THREE.BoxGeometry(1,1,1), new THREE.MeshNormalMaterial({
				transparent: true,
				opacity: 0}));
  cameraModel.add (body);
  return cameraModel;
}

function editPart(Mesh){
    scene.add(Mesh[0]); //身體
	Mesh[0].add(Mesh[1]);//右臂
	Mesh[1].position.set(3, 12.5, 0);
	Mesh[0].add(Mesh[2]);//左臂
	Mesh[2].position.set(9, 12.5, 0);
	Mesh[0].add(Mesh[3]);//右腿
	Mesh[3].position.set(5, 6.5, 0);
	Mesh[0].add(Mesh[4]);//左腿
	Mesh[4].position.set(7, 6.5, 0);
	Mesh[0].add(Mesh[5]);//頭
	Mesh[5].position.set(0, 14.5, 0);
	
	Mesh[0].add(Mesh[6]);//頭外殼
	Mesh[6].position.set(0, 14.5, 0);
	Mesh[0].add(Mesh[7]);//身體外殼
	Mesh[7].position.set(0, 9.5, 0);
	Mesh[0].add(Mesh[8]);//右臂外殼
	Mesh[8].position.set(3, 12.5, 0);
	Mesh[0].add(Mesh[9]);//左臂外殼
	Mesh[9].position.set(9, 12.5, 0);
	Mesh[0].add(Mesh[10]);//右腿外殼
	Mesh[10].position.set(5, 6.5, 0);
	Mesh[0].add(Mesh[11]);//左腿外殼
	Mesh[11].position.set(7, 6.5, 0);
}

function init () {
	clock = new THREE.Clock();
	scene = new THREE.Scene();
	
	renderer = new THREE.WebGLRenderer();
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.setClearColor(0x000000, 0);
	document.body.appendChild(renderer.domElement);
	document.getElementById("body").style.backgroundImage = "url(https://i.imgur.com/EVjpH3e.jpg)"; 
	
	camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
	camera.position.set (-50,40,0);
	camera3rd  = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 1, 1000);
	camera1st  = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 1, 1000);
	cameraGyro = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 1, 1000);
	let controls = new THREE.OrbitControls(camera, renderer.domElement);
	document.body.appendChild(renderer.domElement);
	////////////////////////////////////////////////////////////////
	speed = 0.0;
	angle = 0.0;
	var loader = new THREE.TextureLoader();
	loader.setCrossOrigin('');
	Claratexture = loader.load ('https://i.imgur.com/wW1j06A.png');
	Zombietexture = loader.load ('https://i.imgur.com/zZiPV5H.png');
	Skeletontexture = loader.load ('https://i.imgur.com/tOUMOzM.png');
	Herobrinetexture = loader.load ('https://i.imgur.com/74joVJc.png');
	grasstexture = loader.load ('https://i.imgur.com/MUvFN2X.png');
	treemap = loader.load('https://i.imgur.com/QT00Lre.png');
	var floor = buildGrass(300, 300, 300)
	floor.position.y=-150
	scene.add(floor)
	
	pointlight = new THREE.PointLight(0xFFFFFF, 1);
	pointlight.position.set(0, 100, 0);
	scene.add( pointlight );

	buildBackground();

	parts = buildPart(Claratexture);
	editPart(parts);
	zombie = buildPart(Zombietexture);
	editPart(zombie);
	zombie[0].position.z=-40
	zombie[1].rotation.x=-0.5*Math.PI
	zombie[2].rotation.x=-0.5*Math.PI
	skeleton = buildPart(Skeletontexture);
	editPart(skeleton);
	skeleton[0].position.z=-50
	skeleton[0].position.x=-10
	herobrine = buildPart(Herobrinetexture);
	editPart(herobrine);
	herobrine[0].rotation.y=Math.PI
	herobrine[0].position.z=58
	herobrine[0].position.x=24.5
	
	cameraHelper3rd = makeCameraHelper();
    scene.add (cameraHelper3rd);
	cameraHelper1st = makeCameraHelper();
	scene.add (cameraHelper1st);
	
	gyro = new THREE.Gyroscope();
    parts[5].add (gyro);
    gyro.add (cameraGyro);
	
    cameraGyro.position.set (-35,10,-20); 
    cameraGyro.lookAt (0,0,0);  
}


function update(dt) {

  keyboard.update();
	if ( keyboard.pressed("up") |  keyboard.pressed("W") )  
		speed += 0.5; 
	else 
		speed -= 0.5;
	if ( keyboard.pressed("left") |  keyboard.pressed("A") ) 
		angle += 0.025;               
	if ( keyboard.pressed("right") |  keyboard.pressed("D") )
		angle -= 0.025;                      
	if ( keyboard.pressed("down") |  keyboard.pressed("S") )  
		speed -= 5;    
	
	speed = Math.clamp (speed, 0, 100.0);		//(速度, 最低達到速, 最高達到速)
	vel = new THREE.Vector3(0,0,speed);
	
	vel.applyAxisAngle (new THREE.Vector3(0,1,0), angle);
	pos.add (vel.clone().multiplyScalar(dt)); 	
}

function animate() {

  var dt = clock.getDelta();
  update(dt)
  calcPose(Math.PI/6)
  parts[0].position.copy(pos);
  parts[0].rotation.y = angle;

  if (speed > 0.1) {
	let intKey = keyframe(clock.getElapsedTime());
	parts[1].rotation.x=intKey[1]
	parts[2].rotation.x=intKey[0]
	parts[3].rotation.x=intKey[0]
	parts[4].rotation.x=intKey[1]
	parts[8].rotation.x=intKey[1]
	parts[9].rotation.x=intKey[0]
	parts[10].rotation.x=intKey[0]
	parts[11].rotation.x=intKey[1]
  }
  else{
	parts[1].rotation.x=0
	parts[2].rotation.x=0
	parts[3].rotation.x=0
	parts[4].rotation.x=0
	parts[8].rotation.x=0
	parts[9].rotation.x=0
	parts[10].rotation.x=0
	parts[11].rotation.x=0
  }
  ///////////////////////////////////////////////////////////////////////
  rotateBillboard(tree)
  ///////////////////////////////////////////////////////////////////////
  
  requestAnimationFrame(animate);
  var thirdPos = parts[5].localToWorld (new THREE.Vector3(0,10,-20));
  var thirdAt = parts[5].localToWorld (new THREE.Vector3(0,0,60));
  camera3rd.position.copy (thirdPos);
  camera3rd.lookAt (thirdAt);
  var firstPos = parts[5].localToWorld (new THREE.Vector3(0,0,3.2));
  var firstAt = parts[5].localToWorld (new THREE.Vector3(0,0,60));
  camera1st.position.copy (firstPos);
  camera1st.lookAt (firstAt);
  cameraHelper3rd.position.copy (camera3rd.position);
  cameraHelper3rd.quaternion.copy (camera3rd.quaternion);
  cameraHelper1st.position.copy (camera1st.position);
  cameraHelper1st.quaternion.copy (camera1st.quaternion);
   
  if (use3rd==2)
		renderer.render (scene, camera);
  else if(use3rd==1){
		renderer.render (scene, camera1st);}
  else if(use3rd==3)
		renderer.render (scene, camera3rd);
  else if(use3rd==4)
		renderer.render (scene, cameraGyro);
	
	
}
function render() {
	
	renderer.render(scene, camera);
	
}

function rotateBillboard(mesh) {
  var b = mesh.position.clone(); // billboard location
  var rotaxis = new THREE.Vector3();
  var v, yhat, n;
  
  if (use3rd==2)
    {v = camera.position.clone();}
  else if(use3rd==1){
    v = camera1st.position.clone(); }
  else if(use3rd==3){
    v = camera3rd.position.clone(); }
  else if(use3rd==4){
    v = cameraGyro.position.clone(); }
		
  yhat = new THREE.Vector3(0, 1, 0); // up
  n = new THREE.Vector3(0, 0, 1); // billboard normal

  v.subVectors(v, b); // v-b
  v.sub(yhat.clone().multiplyScalar(v.dot(yhat)));
  v.normalize(); // pxz

  let rotangle = Math.acos(v.dot(n));
  rotaxis.crossVectors(n, v);
  if (rotaxis.dot(yhat) < 0) rotangle *= -1;

  mesh.rotation.y = rotangle;
}

</script>
</body>

</html>